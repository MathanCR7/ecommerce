// backend/controllers/adminCategoryController.js
import mongoose from "mongoose";
import asyncHandler from "express-async-handler";
import path from "path";
import Category from "../models/Category.js";
import Item from "../models/Item.js"; // Import the Item model
import { deleteFile } from "../config/multerConfig.js";

// GET /api/admin/categories - Get ALL categories (for admin panel)
export const getAllAdminCategories = asyncHandler(async (req, res) => {
  console.log("[Ctrl Admin Cat] Fetching all categories for admin");
  const categories = await Category.find({})
    .populate("createdBy", "username email")
    .sort({ createdAt: -1 });
  res.status(200).json({ success: true, categories });
});

// GET /api/admin/categories/:id - Get single category (for admin panel)
export const getAdminCategoryById = asyncHandler(async (req, res) => {
  const { id } = req.params;
  if (!mongoose.Types.ObjectId.isValid(id)) {
    res.status(400);
    throw new Error("Invalid category ID format.");
  }
  const category = await Category.findById(id).populate(
    "createdBy",
    "username email"
  );
  if (!category) {
    res.status(404);
    throw new Error("Category not found.");
  }
  res.status(200).json({ success: true, category });
});

// POST /api/admin/categories - Create new category
// uploadCategoryImage middleware runs first
export const createAdminCategory = asyncHandler(async (req, res) => {
  const { name, description } = req.body;
  const adminId = req.user._id;
  let uploadedFilePath = null;

  if (!name || !name.trim()) {
    res.status(400);
    throw new Error("Category name is required.");
  }

  // Construct potential path early for cleanup
  if (req.file) {
    uploadedFilePath = path
      .join("categories", req.file.filename)
      .replace(/\\/g, "/");
  }

  // Check name uniqueness (case-insensitive)
  const existingCategory = await Category.findOne({
    name: { $regex: `^${name.trim()}$`, $options: "i" },
  });
  if (existingCategory) {
    if (uploadedFilePath) await deleteFile(uploadedFilePath); // Cleanup uploaded file
    res.status(409);
    throw new Error(`Category name "${name.trim()}" already exists.`);
  }

  const category = new Category({
    name: name.trim(),
    description: description?.trim() || "",
    imagePath: uploadedFilePath, // Assign path (can be null)
    createdBy: adminId,
    // Slug is generated by pre-save hook
  });

  try {
    const createdCategory = await category.save();
    // Populate createdBy details for the response
    const populatedCategory = await Category.findById(
      createdCategory._id
    ).populate("createdBy", "username email");
    res.status(201).json({ success: true, category: populatedCategory });
  } catch (saveError) {
    // If saving fails (e.g., validation error in hook), delete the uploaded image
    if (uploadedFilePath) {
      console.error(
        `[Ctrl Admin Cat] Save failed for ${name}. Cleaning up image: ${uploadedFilePath}`
      );
      await deleteFile(uploadedFilePath);
    }
    // Re-throw the original error for the global error handler
    throw saveError;
  }
});

// PUT /api/admin/categories/:id - Update category
// uploadCategoryImage middleware runs first
export const updateAdminCategory = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const { name, description } = req.body;
  let newRelativePath = null;

  if (!mongoose.Types.ObjectId.isValid(id)) {
    res.status(400);
    throw new Error("Invalid category ID format.");
  }

  // Determine path if a new file is uploaded
  if (req.file) {
    newRelativePath = path
      .join("categories", req.file.filename)
      .replace(/\\/g, "/");
  }

  const category = await Category.findById(id);
  if (!category) {
    // If category not found, delete the potentially uploaded new file
    if (newRelativePath) await deleteFile(newRelativePath);
    res.status(404);
    throw new Error("Category not found.");
  }

  let hasChanges = false; // Track if any field is actually modified

  // Check name uniqueness if changed
  const trimmedName = name?.trim();
  if (
    trimmedName &&
    trimmedName.toLowerCase() !== category.name.toLowerCase()
  ) {
    const nameExists = await Category.findOne({
      name: { $regex: `^${trimmedName}$`, $options: "i" },
      _id: { $ne: id },
    });
    if (nameExists) {
      if (newRelativePath) await deleteFile(newRelativePath); // Cleanup file on validation error
      res.status(409);
      throw new Error(`Category name "${trimmedName}" already exists.`);
    }
    category.name = trimmedName; // Update name (slug hook will run on save)
    hasChanges = true;
  }

  // Update description if provided and different
  const trimmedDescription = description?.trim() ?? ""; // Handle null/undefined safely
  if (
    description !== undefined &&
    category.description !== trimmedDescription
  ) {
    category.description = trimmedDescription;
    hasChanges = true;
  }

  // Handle image update
  let oldImagePath = category.imagePath;
  if (newRelativePath) {
    // A new file was uploaded via req.file
    category.imagePath = newRelativePath;
    hasChanges = true;
  }

  // Save only if changes were made
  if (hasChanges) {
    try {
      const updatedCategory = await category.save();

      // Delete old image *after* successful save of the new path
      if (
        newRelativePath && // A new file was saved
        oldImagePath && // There was an old image path
        oldImagePath !== updatedCategory.imagePath // Ensure it's actually different
      ) {
        console.log(`[Ctrl Admin Cat] Deleting old image: ${oldImagePath}`);
        await deleteFile(oldImagePath);
      }

      const populatedCategory = await Category.findById(
        updatedCategory._id
      ).populate("createdBy", "username email");
      res.status(200).json({ success: true, category: populatedCategory });
    } catch (saveError) {
      // If save fails, try to delete the *newly* uploaded file
      if (newRelativePath) {
        console.error(
          `[Ctrl Admin Cat] Save failed for ${category.name}. Cleaning up new image: ${newRelativePath}`
        );
        await deleteFile(newRelativePath);
      }
      throw saveError; // Re-throw
    }
  } else {
    // No changes detected, delete the potentially uploaded file if it wasn't used
    if (newRelativePath) {
      console.log(
        `[Ctrl Admin Cat] No changes detected for ${category.name}. Cleaning up unused upload: ${newRelativePath}`
      );
      await deleteFile(newRelativePath);
    }

    // Return current data if no modifications
    const currentPopulated = await Category.findById(id).populate(
      "createdBy",
      "username email"
    );
    res
      .status(200)
      .json({
        success: true,
        message: "No changes detected.",
        category: currentPopulated,
      });
  }
});

// DELETE /api/admin/categories/:id - Delete single category (triggers item cascade via model hook)
export const deleteAdminCategory = asyncHandler(async (req, res) => {
  const { id } = req.params;
  if (!mongoose.Types.ObjectId.isValid(id)) {
    res.status(400);
    throw new Error("Invalid category ID format.");
  }
  const category = await Category.findById(id);
  if (!category) {
    res.status(404);
    throw new Error("Category not found.");
  }

  // This triggers the pre('deleteOne') hook in Category model
  await category.deleteOne();

  res
    .status(200)
    .json({
      success: true,
      message: `Category "${category.name}" and associated items scheduled for deletion.`,
    });
});

// POST /api/admin/categories/delete-multiple - Delete multiple categories (triggers item cascade for each)
export const deleteMultipleAdminCategories = asyncHandler(async (req, res) => {
  const { ids } = req.body;
  if (!Array.isArray(ids) || ids.length === 0) {
    res.status(400);
    throw new Error("Invalid request: 'ids' array is required.");
  }

  const validIds = ids.filter((id) => mongoose.Types.ObjectId.isValid(id));
  if (validIds.length === 0) {
    res.status(400);
    throw new Error("No valid category IDs provided.");
  }

  let deletedCount = 0,
    errors = [],
    notFoundCount = 0;
  const categoryNames = [];

  for (const id of validIds) {
    try {
      const category = await Category.findById(id);
      if (category) {
        categoryNames.push(category.name);
        // This triggers the pre('deleteOne') hook for each category instance
        await category.deleteOne();
        deletedCount++;
      } else {
        notFoundCount++;
      }
    } catch (error) {
      console.error(`Error processing category ${id} for deletion:`, error);
      errors.push({ id: id, message: error.message || "Deletion failed" });
    }
  }

  let message = `${deletedCount} categories scheduled for deletion.`;
  if (categoryNames.length > 0)
    message = `Categories "${categoryNames.join(
      '", "'
    )}" and associated items scheduled for deletion.`;
  if (notFoundCount > 0) message += ` ${notFoundCount} not found.`;
  if (errors.length > 0) message += ` ${errors.length} failed.`;

  const status = errors.length > 0 ? (deletedCount > 0 ? 207 : 500) : 200;

  res
    .status(status)
    .json({
      success: errors.length === 0,
      message,
      deletedCount,
      notFoundCount,
      errors,
    });
});

// POST /api/admin/categories/:id/move-delete - Move Items then Delete Category
export const moveItemsAndDeleteCategory = asyncHandler(async (req, res) => {
  const { id: categoryIdToDelete } = req.params;
  const { targetCategoryId } = req.body;

  console.log(
    `[Ctrl Admin Cat] Request to move items from ${categoryIdToDelete} to ${targetCategoryId} and delete original.`
  );

  // 1. Validation
  if (!mongoose.Types.ObjectId.isValid(categoryIdToDelete)) {
    res.status(400);
    throw new Error("Invalid category ID format for category to delete.");
  }
  if (!targetCategoryId) {
    // Check if targetCategoryId was provided
    res.status(400);
    throw new Error("Target category ID is required.");
  }
  if (!mongoose.Types.ObjectId.isValid(targetCategoryId)) {
    res.status(400);
    throw new Error("Invalid target category ID format.");
  }
  if (categoryIdToDelete === targetCategoryId) {
    res.status(400);
    throw new Error(
      "Target category cannot be the same as the category being deleted."
    );
  }

  // 2. Check existence of both categories
  // Use Promise.all for potentially faster parallel lookup
  const [categoryToDelete, targetCategory] = await Promise.all([
    Category.findById(categoryIdToDelete),
    Category.findById(targetCategoryId),
  ]);

  if (!categoryToDelete) {
    res.status(404);
    throw new Error(
      `Category to delete (ID: ${categoryIdToDelete}) not found.`
    );
  }
  if (!targetCategory) {
    res.status(404);
    throw new Error(`Target category (ID: ${targetCategoryId}) not found.`);
  }

  // 3. Move Items
  console.log(
    `[Ctrl Admin Cat] Moving items from ${categoryToDelete.name} (${categoryIdToDelete}) to ${targetCategory.name} (${targetCategoryId})...`
  );
  // Use the Item model to update items belonging to the old category
  const updateResult = await Item.updateMany(
    { category: categoryIdToDelete }, // Filter: items in the category to delete
    { $set: { category: targetCategoryId } } // Update: set category to the target ID
  );
  console.log(
    `[Ctrl Admin Cat] ${updateResult.modifiedCount || 0} items moved.`
  ); // Use modifiedCount which reflects actual changes

  // 4. Delete Original Category (Bypassing Item Cascade Hook)
  console.log(
    `[Ctrl Admin Cat] Deleting original category ${categoryToDelete.name} (${categoryIdToDelete})...`
  );
  // Use findByIdAndDelete to bypass document middleware 'deleteOne' hooks (which would cascade delete items)
  const deletedCategory = await Category.findByIdAndDelete(categoryIdToDelete);

  if (!deletedCategory) {
    // This case is unlikely if found earlier, but handle defensively
    console.warn(
      `[Ctrl Admin Cat] Category ${categoryIdToDelete} was not found during final deletion phase, though items may have been moved.`
    );
    // Even if deletion failed here, items *were* moved. Success message reflects move.
    res.status(500); // Indicate server error
    throw new Error(
      `Moved ${updateResult.modifiedCount} items, but failed to delete original category "${categoryToDelete.name}". Manual cleanup might be needed.`
    );
  }

  // 5. Manually Delete Category Image (since findByIdAndDelete bypasses hooks)
  const imagePathToDelete = deletedCategory.imagePath; // Get path from the deleted document data
  if (imagePathToDelete) {
    console.log(
      `[Ctrl Admin Cat] Deleting image file for deleted category: ${imagePathToDelete}`
    );
    await deleteFile(imagePathToDelete); // Assuming deleteFile handles its own errors gracefully
  } else {
    console.log(
      `[Ctrl Admin Cat] No image file associated with deleted category ${deletedCategory.name}.`
    );
  }

  console.log(
    `[Ctrl Admin Cat] Successfully moved items and deleted category ${deletedCategory.name}.`
  );
  res.status(200).json({
    success: true,
    message: `Successfully moved ${updateResult.modifiedCount} items to "${targetCategory.name}" and deleted category "${deletedCategory.name}".`,
    movedCount: updateResult.modifiedCount || 0, // Ensure count is a number
  });
});
